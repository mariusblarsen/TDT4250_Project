/*
 * generated by Xtext 2.23.0
 */
package tdt4250.ganttproject.validation;

import java.util.Date;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.validation.Check;

import tdt4250.ganttproject.gpx.AbstractTask;
import tdt4250.ganttproject.gpx.Dependency;
import tdt4250.ganttproject.gpx.GpxPackage;
import tdt4250.ganttproject.gpx.Project;
import tdt4250.ganttproject.gpx.Task;

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class GpxValidator extends AbstractGpxValidator {
	
	public static final String END_DATE_NOT_EXPECTED = "Task %s: end date cannot be explicitly specified for a task with subtasks";
	public static final String END_DATE_EARLIER_THAN_START_DATE = "Task %: end date cannot be before than start date";
	public static final String DURATION_NOT_EXPECTED = "Task %s: duration cannot be explicitly specified for a task with subtasks";
	public static final String DURATION_EXPECTED = "Task %s: no duration specified";
	public static final String START_DATE_NOT_EXPECTED_WITH_SUBTASKS = "Task %s: start date cannot be explicitly specified for a task with subtasks";
	public static final String START_DATE_NOT_EXPECTED_WITH_DEPENDENCIES = "Task %s: start date cannot be explicitly specified for a task which depends on other tasks";
	public static final String START_DATE_EXPECTED = "Task %s: no start date specified";
	public static final String CIRCULAR_DEPENDENCY = "Task %s can't depend on a task already dependant on itself";
	public static final String SELF_DEPENDENCY = "Task %s can't depend on itself";
	public static final String NAME_CHARACTER = "Task and Milestone names can only consist of characters, numbers, '_' and whitespace.";
	public static final String DEPENDEES_REF = "- Couldn't resolve reference. \n- Note: References can't contain special characters.";

	
	@Check
	public void checkTaskEndDateConsistent(Task task) {
		Date endDate = task.getEndDate();
		
		if (endDate != null) {
			if (!task.getSubtasks().isEmpty()) {
				error(formatMessage(END_DATE_NOT_EXPECTED, task.getName()), GpxPackage.Literals.ABSTRACT_TASK__END_DATE);
			} else {
				Date startDate = task.getStartDate();
				if (startDate != null && (startDate.after(endDate))) {
					error(formatMessage(END_DATE_EARLIER_THAN_START_DATE, task.getName()), GpxPackage.Literals.ABSTRACT_TASK__END_DATE);
				}
			}
		}
	}
	
	@Check
	public void checkTaskDurationConsistent(Task task) {
		int duration = task.getDuration();
				
		if (!task.getSubtasks().isEmpty()) {
			if (duration > 0) {
				error(formatMessage(DURATION_NOT_EXPECTED, task.getName()), GpxPackage.Literals.TASK__DURATION);
			}			 
		} else if (duration == 0 && task.getEndDate() == null) {
			error(formatMessage(DURATION_EXPECTED, task.getName()), GpxPackage.Literals.TASK__DURATION);
		}
	}
	
	@Check
	public void checkTaskStartDateConsistent(Task task) {
		Date startDate = task.getStartDate();
				
		if (!task.getSubtasks().isEmpty()) {
			if (startDate != null) {
				error(formatMessage(START_DATE_NOT_EXPECTED_WITH_SUBTASKS, task.getName()), GpxPackage.Literals.TASK__START_DATE);
			}			 
		} else if (task.getDependency() != null) {
			if (startDate != null) {
				error(formatMessage(START_DATE_NOT_EXPECTED_WITH_DEPENDENCIES, task.getName()), GpxPackage.Literals.TASK__START_DATE);
			}
		} else if (startDate == null) {
			error(formatMessage(START_DATE_EXPECTED, task.getName()), GpxPackage.Literals.TASK__START_DATE);
		}
	}
	
	@Check
	public void checkDependencies(AbstractTask ATask) {
		if (ATask.getDependency() != null) {
			for (AbstractTask masterTask: ATask.getDependency().getDependees()) {
				if (masterTask.eIsProxy()) {
					error(formatMessage(DEPENDEES_REF), 
							GpxPackage.Literals.ABSTRACT_TASK__DEPENDENCY);
				}
				if (masterTask == ATask) {
					error(formatMessage(SELF_DEPENDENCY, ATask.getName()),
							GpxPackage.Literals.ABSTRACT_TASK__DEPENDENCY);
				} if (masterTask.getDependency() != null
						&& masterTask != ATask) {
					for (AbstractTask masterOfMasterTask: masterTask.getDependency().getDependees()) {
						if (masterOfMasterTask == ATask) {
							error(formatMessage(CIRCULAR_DEPENDENCY, ATask.getName()),
															GpxPackage.Literals.ABSTRACT_TASK__DEPENDENCY);
						}
					}
				}		 
			}
		}
	}

	@Check
	public void checkTaskName(AbstractTask task) {
		if (task.getName() != null) {
			Pattern pattern = Pattern.compile("[^a-zA-Z0-9_ \n\t\r]");
			Matcher matcher = pattern.matcher(task.getName());
			if (matcher.find()) {
				error(formatMessage(NAME_CHARACTER), 
						GpxPackage.Literals.ABSTRACT_TASK__NAME);
			}			 
		}
	}
	
	
	private String formatMessage(String template, String...params) {
		return String.format(template, params);
	}
	
	
}
